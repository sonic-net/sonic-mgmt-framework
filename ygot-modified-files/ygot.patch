Binary files ygot-dir-orig/ygot/.git/index and ygot-dir/ygot/.git/index differ
diff -ruN ygot-dir-orig/ygot/util/debug.go ygot-dir/ygot/util/debug.go
--- ygot-dir-orig/ygot/util/debug.go	2019-09-19 13:30:08.402915000 -0700
+++ ygot-dir/ygot/util/debug.go	2019-09-19 11:04:09.098659000 -0700
@@ -53,6 +53,14 @@
 	fmt.Println(globalIndent + out)
 }
 
+func IsDebugLibraryEnabled () bool {
+	return debugLibrary
+}
+
+func IsDebugSchemaEnabled () bool {
+	return debugSchema
+}
+
 // DbgSchema prints v if the package global variable debugSchema is set.
 // v has the same format as Printf.
 func DbgSchema(v ...interface{}) {
@@ -177,6 +185,9 @@
 
 // YangTypeToDebugString returns a debug string representation of a YangType.
 func YangTypeToDebugString(yt *yang.YangType) string {
+	if !debugLibrary {
+		return ""
+	}
 	out := fmt.Sprintf("(TypeKind: %s", yang.TypeKindToName[yt.Kind])
 	if len(yt.Pattern) != 0 {
 		out += fmt.Sprintf(", Pattern: %s", strings.Join(yt.Pattern, " or "))
diff -ruN ygot-dir-orig/ygot/util/reflect.go ygot-dir/ygot/util/reflect.go
--- ygot-dir-orig/ygot/util/reflect.go	2019-09-19 13:30:08.407695000 -0700
+++ ygot-dir/ygot/util/reflect.go	2019-09-19 11:04:09.118335000 -0700
@@ -196,8 +196,10 @@
 
 // InsertIntoMap inserts value with key into parent which must be a map.
 func InsertIntoMap(parentMap interface{}, key interface{}, value interface{}) error {
-	DbgPrint("InsertIntoMap into parent type %T with key %v(%T) value \n%s\n (%T)",
-		parentMap, ValueStrDebug(key), key, pretty.Sprint(value), value)
+    if debugLibrary {
+	   DbgPrint("InsertIntoMap into parent type %T with key %v(%T) value \n%s\n (%T)",
+	      parentMap, ValueStrDebug(key), key, pretty.Sprint(value), value)
+    }
 
 	v := reflect.ValueOf(parentMap)
 	t := reflect.TypeOf(parentMap)
@@ -288,7 +290,7 @@
 		n = reflect.Zero(ft.Type)
 	}
 
-	if !isFieldTypeCompatible(ft, n) {
+	if !isFieldTypeCompatible(ft, n) && !IsValueTypeCompatible(ft.Type, v) {
 		return fmt.Errorf("cannot assign value %v (type %T) to struct field %s (type %v) in struct %T", fieldValue, fieldValue, fieldName, ft.Type, parentStruct)
 	}
 
diff -ruN ygot-dir-orig/ygot/util/schema.go ygot-dir/ygot/util/schema.go
--- ygot-dir-orig/ygot/util/schema.go	2019-09-19 13:30:08.411894000 -0700
+++ ygot-dir/ygot/util/schema.go	2019-09-19 11:04:09.133009000 -0700
@@ -233,7 +233,9 @@
 	found := true
 	DbgSchema("traversing schema Dirs...")
 	for ; len(p) > 0; p = p[1:] {
-		DbgSchema("/%s", p[0])
+		if IsDebugSchemaEnabled() {
+			DbgSchema("/%s", p[0])	
+		}
 		var ok bool
 		s, ok = s.Dir[p[0]]
 		if !ok {
@@ -261,10 +263,13 @@
 		return nil, nil
 	}
 	entries := FindFirstNonChoiceOrCase(schema)
-
-	DbgSchema("checking for %s against non choice/case entries: %v\n", p[0], stringMapKeys(entries))
+	if IsDebugSchemaEnabled() {
+		DbgSchema("checking for %s against non choice/case entries: %v\n", p[0], stringMapKeys(entries))	
+	}
 	for pe, entry := range entries {
-		DbgSchema("%s ? ", pe)
+		if IsDebugSchemaEnabled() {
+			DbgSchema("%s ? ", pe)	
+		}
 		if pe == p[0] {
 			DbgSchema(" - match\n")
 			return entry, nil
diff -ruN ygot-dir-orig/ygot/ytypes/container.go ygot-dir/ygot/ytypes/container.go
--- ygot-dir-orig/ygot/ytypes/container.go	2019-09-19 13:30:08.416535000 -0700
+++ ygot-dir/ygot/ytypes/container.go	2019-09-19 11:04:09.144144000 -0700
@@ -17,7 +17,7 @@
 import (
 	"fmt"
 	"reflect"
-
+	
 	"github.com/kylelemons/godebug/pretty"
 	"github.com/openconfig/goyang/pkg/yang"
 	"github.com/openconfig/ygot/util"
@@ -71,7 +71,7 @@
 				if errs := Validate(cschema, fieldValue); errs != nil {
 					errors = util.AppendErrs(errors, util.PrefixErrors(errs, cschema.Path()))
 				}
-			case !util.IsValueNilOrDefault(structElems.Field(i).Interface()):
+			case !structElems.Field(i).IsNil():
 				// Either an element in choice schema subtree, or bad field.
 				// If the former, it will be found in the choice check below.
 				extraFields[fieldName] = nil
@@ -217,7 +217,10 @@
 		}
 	}
 
-	util.DbgPrint("container after unmarshal:\n%s\n", pretty.Sprint(destv.Interface()))
+	if util.IsDebugLibraryEnabled() {
+		util.DbgPrint("container after unmarshal:\n%s\n", pretty.Sprint(destv.Interface()))
+	} 
+	
 	return nil
 }
 
diff -ruN ygot-dir-orig/ygot/ytypes/leaf.go ygot-dir/ygot/ytypes/leaf.go
--- ygot-dir-orig/ygot/ytypes/leaf.go	2019-09-19 13:30:08.421645000 -0700
+++ ygot-dir/ygot/ytypes/leaf.go	2019-09-19 11:04:09.170862000 -0700
@@ -79,7 +79,7 @@
 
 	switch ykind {
 	case yang.Ybinary:
-		return util.NewErrs(validateBinary(schema, value))
+		return util.NewErrs(validateBinary(schema, rv))
 	case yang.Ybits:
 		return nil
 		// TODO(mostrowski): restore when representation is decided.
@@ -418,12 +418,10 @@
 	return nil
 }
 
-// YANGEmpty is a derived type which is used to represent the YANG empty type.
+// YANGEmpty is a derived type which is used to represent the YANG
+// empty type.
 type YANGEmpty bool
 
-// Binary is a derived type which is used to represent the YANG binary type.
-type Binary []byte
-
 // unmarshalLeaf unmarshals a scalar value (determined by json.Unmarshal) into
 // the parent containing the leaf.
 //   schema points to the schema for the leaf type.
@@ -720,7 +718,9 @@
 		return nil, fmt.Errorf("%s Î›EnumTypes function returned wrong type %T, want map[string][]reflect.Type", t, ei)
 	}
 
-	util.DbgPrint("path is %s for schema %s", absoluteSchemaDataPath(schema), schema.Name)
+	if util.IsDebugLibraryEnabled() {
+		util.DbgPrint("path is %s for schema %s", absoluteSchemaDataPath(schema), schema.Name)	
+	}
 
 	return enumTypesMap[absoluteSchemaDataPath(schema)], nil
 }
diff -ruN ygot-dir-orig/ygot/ytypes/list.go ygot-dir/ygot/ytypes/list.go
--- ygot-dir-orig/ygot/ytypes/list.go	2019-09-19 13:30:08.426123000 -0700
+++ ygot-dir/ygot/ytypes/list.go	2019-09-19 11:04:09.184244000 -0700
@@ -350,7 +350,9 @@
 			return err
 		}
 	}
-	util.DbgPrint("list after unmarshal:\n%s\n", pretty.Sprint(parent))
+	if util.IsDebugLibraryEnabled() {
+		util.DbgPrint("list after unmarshal:\n%s\n", pretty.Sprint(parent))	
+	}
 
 	return nil
 }
@@ -388,17 +390,96 @@
 		if err != nil {
 			return err
 		}
-
 		fv := val.Elem().FieldByName(fn)
 		ft := fv.Type()
 		if util.IsValuePtr(fv) {
 			ft = ft.Elem()
 		}
-
-		nv, err := StringToType(ft, fieldVal)
+		sf, ok := val.Elem().Type().FieldByName(fn)
+		if ok == false {
+			return fmt.Errorf("Field %s not present in the struct %s", fn, val.Elem())
+		}
+		cschema, err := childSchema(schema, sf)
 		if err != nil {
 			return err
 		}
+		keyLeafKind := cschema.Type.Kind
+		if keyLeafKind == yang.Yleafref {
+			lrfschema, err := resolveLeafRef(cschema)
+			if err != nil {
+				return err
+			}
+			keyLeafKind = lrfschema.Type.Kind
+		}
+
+		var nv reflect.Value
+		if keyLeafKind == yang.Yunion {
+			sks, err := getUnionKindsNotEnums(cschema)
+			if err != nil {
+				return err
+			}
+			for _, sk := range sks {
+				gv, err := StringToType(reflect.TypeOf(yangBuiltinTypeToGoType(sk)), fieldVal)
+				if err == nil {
+					mn := "To_" + ft.Name()
+					mapMethod := val.MethodByName(mn)
+					if !mapMethod.IsValid() {
+						return fmt.Errorf("%s does not have a %s function", val, mn)
+					}
+					ec := mapMethod.Call([]reflect.Value{gv})
+					if len(ec) != 2 {
+						return fmt.Errorf("%s %s function returns %d params", ft.Name(), mn, len(ec))
+					}
+					ei := ec[0].Interface()
+					ee := ec[1].Interface()
+					if ee != nil {
+						return fmt.Errorf("unmarshaled %v type %T does not have a union type: %v", fieldVal, fieldVal, ee)
+					}
+					nv = reflect.ValueOf(ei)
+					break
+				}
+			}
+			
+			if nv.IsValid() == false {
+				ets, err := schemaToEnumTypes(cschema, elmT)
+				if err != nil {
+					return err
+				}
+				for _, et := range ets {
+					ev, err := castToEnumValue(et, fieldVal)
+					if err != nil {
+						return err
+					}
+					if ev != nil {
+						mn := "To_" + ft.Name()
+						mapMethod := val.MethodByName(mn)
+						if !mapMethod.IsValid() {
+							return fmt.Errorf("%s does not have a %s function", val, mn)
+						}
+						ec := mapMethod.Call([]reflect.Value{reflect.ValueOf(ev)})
+						if len(ec) != 2 {
+							return fmt.Errorf("%s %s function returns %d params", ft.Name(), mn, len(ec))
+						}
+						ei := ec[0].Interface()
+						ee := ec[1].Interface()
+						if ee != nil {
+							return fmt.Errorf("unmarshaled %v type %T does not have a union type: %v", fieldVal, fieldVal, ee)
+						}
+						nv = reflect.ValueOf(ei)
+						break
+					}
+					fmt.Errorf("could not unmarshal %v into enum type: %s\n", fieldVal, err)
+				}
+				if nv.IsValid() == false {
+					return fmt.Errorf("could not create the value type for the field name %s  with the value %s", fn, fieldVal)
+				}
+			}
+		} else {
+			nv, err = StringToType(ft, fieldVal)
+			if err != nil {
+				return err
+			}
+		}
 		return util.InsertIntoStruct(val.Interface(), fn, nv.Interface())
 	}
 
@@ -494,6 +575,9 @@
 	}
 
 	// TODO(yusufsn): When the key is a leafref, its target should be filled out.
+    if (len(keys) == 0) { 
+         return nil, nil
+    } 
 	mapVal, err := makeValForInsert(schema, root, keys)
 	if err != nil {
 		return nil, fmt.Errorf("failed to create map value for insert, root %T, keys %v: %v", root, keys, err)
diff -ruN ygot-dir-orig/ygot/ytypes/node.go ygot-dir/ygot/ytypes/node.go
--- ygot-dir-orig/ygot/ytypes/node.go	2019-09-19 13:30:08.431085000 -0700
+++ ygot-dir/ygot/ytypes/node.go	2019-09-19 11:04:09.204588000 -0700
@@ -286,6 +286,11 @@
 		if err != nil {
 			return nil, err
 		}
+
+		if (key == nil) {
+			return []*TreeNode{{Path: traversedPath,Schema: schema,Data: root,}}, nil
+		}
+
 		nodes, err := retrieveNode(schema, rv.MapIndex(reflect.ValueOf(key)).Interface(), util.PopGNMIPath(path), appendElem(traversedPath, path.GetElem()[0]), args)
 		if err != nil {
 			return nil, err
diff -ruN ygot-dir-orig/ygot/ytypes/unmarshal.go ygot-dir/ygot/ytypes/unmarshal.go
--- ygot-dir-orig/ygot/ytypes/unmarshal.go	2019-09-19 13:30:08.436899000 -0700
+++ ygot-dir/ygot/ytypes/unmarshal.go	2019-09-19 11:04:09.221983000 -0700
@@ -73,7 +73,10 @@
 	if schema == nil {
 		return fmt.Errorf("nil schema for parent type %T, value %v (%T)", parent, value, value)
 	}
-	util.DbgPrint("Unmarshal value %v, type %T, into parent type %T, schema name %s", util.ValueStrDebug(value), value, parent, schema.Name)
+	
+	if (util.IsDebugLibraryEnabled()) {
+		util.DbgPrint("Unmarshal value %v, type %T, into parent type %T, schema name %s", util.ValueStrDebug(value), value, parent, schema.Name)	
+	}
 
 	if enc == GNMIEncoding && !(schema.IsLeaf() || schema.IsLeafList()) {
 		return errors.New("unmarshalling a non leaf node isn't supported in GNMIEncoding mode")
diff -ruN ygot-dir-orig/ygot/ytypes/util_schema.go ygot-dir/ygot/ytypes/util_schema.go
--- ygot-dir-orig/ygot/ytypes/util_schema.go	2019-09-19 13:30:08.441339000 -0700
+++ ygot-dir/ygot/ytypes/util_schema.go	2019-09-19 11:04:09.233347000 -0700
@@ -137,8 +137,10 @@
 // if the struct tag is invalid, or nil if tag is valid but the schema is not
 // found in the tree at the specified path.
 func childSchema(schema *yang.Entry, f reflect.StructField) (*yang.Entry, error) {
-	pathTag, _ := f.Tag.Lookup("path")
-	util.DbgSchema("childSchema for schema %s, field %s, tag %s\n", schema.Name, f.Name, pathTag)
+	if util.IsDebugSchemaEnabled() {
+		pathTag, _ := f.Tag.Lookup("path")
+		util.DbgSchema("childSchema for schema %s, field %s, tag %s\n", schema.Name, f.Name, pathTag)	
+	}
 	p, err := pathToSchema(f)
 	if err != nil {
 		return nil, err
@@ -186,8 +188,9 @@
 		return nil, nil
 	}
 	entries := util.FindFirstNonChoiceOrCase(schema)
-
-	util.DbgSchema("checking for %s against non choice/case entries: %v\n", p[0], stringMapKeys(entries))
+	if util.IsDebugSchemaEnabled() {
+		util.DbgSchema("checking for %s against non choice/case entries: %v\n", p[0], stringMapKeys(entries))
+	}
 	for name, entry := range entries {
 		util.DbgSchema("%s ? ", name)
 
diff -ruN ygot-dir-orig/ygot/ytypes/validate.go ygot-dir/ygot/ytypes/validate.go
--- ygot-dir-orig/ygot/ytypes/validate.go	2019-09-19 13:30:08.445376000 -0700
+++ ygot-dir/ygot/ytypes/validate.go	2019-09-19 11:04:09.245482000 -0700
@@ -74,7 +74,7 @@
 		errs = ValidateLeafRefData(schema, value, leafrefOpt)
 	}
 
-	util.DbgPrint("Validate with value %v, type %T, schema name %s", util.ValueStr(value), value, schema.Name)
+	util.DbgPrint("Validate with value %v, type %T, schema name %s", util.ValueStrDebug(value), value, schema.Name)
 
 	switch {
 	case schema.IsLeaf():
